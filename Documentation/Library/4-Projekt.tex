% !TeX spellcheck = de_DE
\chapter{Konzeption}
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{Graphics/KonzeptApp.png}
	\caption{Grobkonzept für Applikation}
	\label{fig1}
\end{figure}
\FloatBarrier
Die Applikation besteht aus drei Teilen. Einem Webserver, der eine API und statische Clientfiles zur Verfügung stellt, der Client im Browser, welcher die API konsumiert sowie eine Android Applikation welche die Website lädt. 
 
\section{Technologiestack}
Wie in dem Grobkonzept beschrieben, wird für die Applikation einen Technologiestack gebraucht, welcher  eine skalierbare API sowie eine gute Integration der API mit einer Browser Frontend Anwendung bietet. Folgende Anforderungen werden an den Technologiestack gestellt:
\begin{itemize}
	\itemsep-0.5em
	\item Skalierbare REST API
	\item Einfacher und schneller Umgang mit AJAX
	\item Gute Integration zwischen API und HTML/JS Client
	\item Responsive Design, Integration mit OAUTH für 3rd Party Authentisierung
	\item Persistance Layer (Datenbankunterstützung)
\end{itemize} 

\subsection{MVC Frameworks}
Komplexe Applikationen werden vorzugsweise mit MVC Frameworks erstellt. Über MVC APIs sind Routing,  Logik sowie Präsentationsschicht gut voneinander Abstrahiert. Es ist gut möglich, für Views mit verschiedenen Daten über ein Model zu versehen, oder auch ein Logisches Routing für eine API zu entwickeln. Folgende Graphik zeigt ein MVC Konzept. Der Client sendet einen Request zu dem Server und wird vom Routing zur Logik im System weitergeleitet. Die Logik findet das richtige Model sowie die dazugehörige View.  Die View wird mit dem Model gerendert und es entsteht eine Antwort, welche dem Client zurückgesendet wird. In einer REST API ist die View JSON. Das Model wird in JSON umgewandelt und versendet. 

Folgendes Code-Beispiel - die Funktion list() -  zeigt, wie alle Courts aus dem Persistance Layer selektiert werden und per JSON zum Client gesendet werden. Dies ist ein API Endpunkt zur auflistung von Courts (http://webserver/courts). Gut zu sehen ist, dass die jsonp() Funktion als Renderer gebraucht wird anstatt eine Standard-View. 
\begin{lstlisting}
exports.list = function(req, res) { 
	Court.find().sort('-created').populate('user')
	 .exec(function(err, courts) {
		if (err) {
			return res.status(400).send({
				message: 
				 errorHandler.getErrorMessage(err)
			});
		} else {
		res.jsonp(courts);
		}
	});
};
\end{lstlisting}

Mit einem MVC Framework auf der Server-Seite kann man so gut abstrahierte und ausbaufähige - skalierbare - APIs erstellen. Diese APIs müssen nun jedoch vom Client Browser verarbeitet werden können. Folgende Möglichkeiten bieten sich an:
\begin{itemize}
	\item Parallel zu der REST API werden Renderer gebaut, welche das Model mit einer View in eine - für den Client statische - Website rendern. Der Client verfügt hier ausschliesslich Logik um die verschiedenen Webseiten abzurufen. 
	\item Ein Website-Skelett mit Logik wird beim ersten Aufruf an den Client verschickt. Der Client bezieht nun Daten aus der REST API und reichert die schon vorhandenen Views mit den Objekten - gesendet über AJAX - selber an. 
\end{itemize}
Eine parallele Implementierung zur Rest API geht entgegen dem Basis Konzept, dass alle Applikationen so gut wie möglich von der REST API profitieren. Zusätzlich würde bei einer parallelen Implementierung jeder Klick in einer Aktualisierung der Applikation resultieren. Dies ist unerwünscht, da sich die Website nicht schnell und intuitiv anfühlt. Man hat bei jedem Klick eine Downtime, da viel Daten übertragen werden müssen, und der Browser den DOM jedes mal neu Aufbauen muss. Bei der zweiten Option wird die Website nur einmal heruntergeladen. Der DOM wird nach dem Download aufgebaut und von der Logik verändert. Klicks lösen einen viel geringeren Aufwand von Server bis Client aus und somit ist die Downtime viel kleiner. Die Applikation fühlt sich schneller und intuitiver an. 

Wie bei dem Server, kann man auch bei der Applikation ein MVC Pattern implementieren. Ein Routing definiert, bei welchr URL welche View aufgerufen wird. Bei dem Aufruf einer View ist ein Controller hinterlegt, welcher bei der API das Model und Objekt besorgt. Die View rendert die vom Controller generierten Daten

\glqq Figure Angular JS \grqq 

Server und Client MVCs können so miteinander Kombiniert werden und es entsteht eine skalierbare und wartbare Applikationsumgebung.


\subsubsection{Server MVCs}
MVCs für den Server gibt es verschiedene:
\begin{itemize}
	\item Spring Framework - Java
	\item ExpressJS - JSON
	\item Rails - Ruby
\end{itemize}

\subsubsection{Client MVCs}
MVC für den Server sind ausschliesslich in Javascript geschrieben:
\begin{itemize}
	\item AngularJS
	\item ???
	\end{itemize}

\subsubsection{Stacks}
Eine Konfiguration des Client- sowie Server MVCs, damit beide gut miteinander Funktionieren ist zusätzlich wichtig. In der Evaluation wird somit folgende Konfigurationen abgewogen:
\begin{itemize}
	\item Spring Framework mit AngularJS
	\item Express Framework mit AngularJS
\end{itemize}

\subsection{Spring + AngularJS}
Spring ist ein MVC Framework in Java. Man Programmiert in der J2EE Umgebung und bietet eine API zum Client. Gleichzeitig sendet man den AngularJS Stack zum Client, welcher anschliessend die API konsumiert. Als Persistance Layer können Relationale Datenbanken wie MySQL, Oracle oder Sybase verwendet werden. Über Data Access Object wird dieser Layer angesprochen und in Models Emuliert. 

Folgende Vor- / Nachteile bring das Spring-Angular Setup mit:
\begin{itemize}
		 \itemsep-0.5em
	\item + reife Technologien, Markt erprobt
	\item + viel Know-How auf dem Markt in Java/Spring
	\item + Anbindung an Zahlreiche Persistance Layer Applikationen
	\item - Viele Daten-Transformationen (Relationale DB <-> Java Objekt <-> JSON Object)
	\item - Kompliziertes Setup
\end{itemize}

\newpage
\subsection{MEAN Stack}
Der MEAM Stack besteht aus folgender Produkten:
\begin{itemize}
		 \itemsep-0.5em
	\item M - MongoDB, der Skalierbare Persistance Layer
	\item E - ExpressJS, ein MVC um APIs zu entwickeln
	\item A - AngularJS, ein MVC auf dem Client um Sing-Page Applikationen zu erstellen, welche auf die ExpressJS API zugreifen.
	\item N - NodeJS, JavaScript Applikationsserver, welcher sehr gut skalierbar ist.
\end{itemize}

Folgende Vor- / Nachteile bring das MEAN Stack Setup mit:
\begin{itemize}
		 \itemsep-0.5em
	\item + Kleine Daten Transformationen (JSON Object wird in MongoDB gespeichert)
	 \item + Gleiche Programmiersprachen (JavaScript, HTML, CSS)
	\item + Einfaches Setup, grosse Flexibilitäten
	\item + Innovative Technologien
	\item - Wenig Markt erprobt
\end{itemize}

\subsection{Entscheidung}
Da das Ergebnis dieser Arbeit ein Proof of Concept darstellt, und die Applikation nicht ausgereift sein wird zum Zeitpunkt der Abgabe, sowie eine produktiver Nutzen nicht das Ziel dieser Aufgabenstellung ist, will der Autor mit möglichst innovativen, flexiblen und einfachen Technologien arbeiten. Der MEAN Stack scheint dadurch der optimale Kandidat für dieses Projekt.

\section{Architektur}
Die Applikation ist aufgeteilt auf einen Server, sowie auf einen Client, welcher ein Browser oder eine Android App ist. Auf dem Server sind alle Daten hinterlegt:
\begin{itemize}
	\itemsep -0.5em
	\item Gespeicherte Objekte in MongoDB
	\item Server Logik
	\item Client Daten, welche vom Browser über HTTP abgefragt werden
\end{itemize}

Im Anfangszustand hat der Client keine Daten. Der Client bekommt die Daten bei dem Abruf der Applikations URL über HTTP. Er baut nun die Logik im Browser Cache auf und startet das JavaScript Programm. Das JavaScript Programm lädt nun die auf dem Server gespeicherten Objekte über HTTP AJAX Abrufe und stellt diese dar.  

Die Logik von Server wie auch Client benutzt das M(V)C Pattern. Objecte werden in Models - inklusive Business Logik -  gespeichert, der Controller beinhaltet die Applikationslogik, welche das Model sowie die View auswählt. Die View rendert nun das Model in ein bestimmtes Schema (siehe Abbildung \ref{DetAppArch}). 
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{Graphics/DetailAppArch.png}
	\caption{Detaillierte Applikations Architektur}
	\label{DetAppArch}
\end{figure}


\section{DB Design}
In der Applikation gibt es kein Relationales Datenbankmodel. MongoDB arbeiet mit Dokumenten, sowie Referenzen. Dokumente sind JSON-Objekte in JavasScript, welche in MongoDB als Dokument gespeichert werden. Ein Objekt ist eine Representation von Business Objekten in der Applikation.

Das User-Objekt repräsentiert der User der Applikation. Der User hat einen Namen, einen Usernamen, ein Passwort (encrypted und salted), Berechtigungen und Freunde. Zusätzlich werden Ihm andere Objekte zugeordnet sowie andere User (Repräsentation als Freund).

Das Court-Objekt repräsentiert ein Racketsportzentrum der Applikation. Dieses Objekt wird benötigt um den Physikalischen Austragungsort eines Spieles zu definieren. Das Objekt beinhaltet einen Namen, eine Adresse (inklusive Koordinaten für eine zukünftige Umkreissuche), was für Sportarten gespielt werden können und welche User in diesem Racketsportzentrum spielen wollen.

Das Match-Objekt respäsentiert das Spiel, welches geplant, ausgetragen oder beendet ist. Das Spiel-Modell definiert zwei oder einen Spieler, einen Status, eine Sportart, ein Court, mehrere Datumvorschläge, maximal fixes Datum, eine Punkzahl, sowie ein Gewinner. Hinter dem Match-Objekt existiert ein relativ grosser Business-Workflow, welcher im Kapitel <<<<IMPLEMENTATION Matchmaking>>>> definiert ist. 

Das Liga-Objekt repräsntiert eine Liga. Verschiedene Benutzer können einer Liga beitereten und sind nach Beitritt bestimmten regeln unterworfen. Dafür können die Benutzer spiele für die Liga spielen und so Punkte für einen optionalen Preis sammeln. Die Liga beinhaltet neben einem Namen, einer Sportart, einem Standort (inklusive Koordinaten, für zukünftige Umkreissuche), einem Niveau, Start- und Enddatum, einem Preis und einem Matchmaking Plan (wird später im Dokument erläuert>>>>>>>REF). 

Folgende Grafik zeigt die Beziehung der Verschiedenen Schemas auf, das Datenbankmodell ist nicht Relational, und somit nicht normalisiert. 
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{Graphics/DBModel.png}
	\caption{Datenbank Modell}
	\label{DBMOdel}
\end{figure}

\newpage
\section{GUI}
Als GUI wird ein standard Bootstrap Design verwendet. Ohne Authentisierung kann nur die Home-Page gesehen werden sowie die Login und Signup Page. Für alle anderen Seiten muss der Benutzer authentisiert sein. Sobald die Authentisierung durchgeführt wurde, gibt es können die Elemente (Nach Datenbank) Benutzer, Liga, Racketsportzentrum sowie Spiele selektiert werden. Innerhalb der einzelnen Menu kann man verschiedene Operationen direkt ansteuern, einige nur über andere Operationen. Folgendes Diagram zeigt die Interaktion durch die verschiedenen Views.
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{Graphics/GUIInteraction.png}
	\caption{GUI Interaktions Modell}
	\label{GUIInteraction}
\end{figure}

\subsection{User Section}
Die User Section einhaltet drei Views die direkt aus dem Menu erreichbar sind. Die erste View User Profile ermöglicht dem User, Details über sich preiszugeben. Er kann zusätzlich das Passwort ändern. Inder Friends view kann er neue Friendrequests erstellen, und pendente Friendrequests annehmen oder ablehnen. Die Social Account View bietet eine Verknüpfung von Social Accounts mit der Applikation an.

\subsection{Court Section}
Die Court Section beinhaltet vier Views sowie eine Aktion. In der new Court View kann ein neues Racketsportzentrum registriert werden. In der List Courts view findet man alle  Racketsportzentren und erreicht bei klick auf ein Zentrum die View Court Details View. In dieser View kann man alle Details des Racketsportzentrum anschauen, sowie alle Spieler, welche in diesem Racketsportzentrum spielen. Durch klick auf den Spieler kann in die New Match View gewechselt werden, um einen Spieler herauszufordern. Von der Detail View kann man zusätzlich das Court löschen, sofern man das Court erstellt hat oder ein Admin ist.

\subsection{League Section}
Die League Section beinhaltet vier Views sowie eine Aktion. In der New League View kann ein neues Liga registriert werden. In der List League View findet man alle  Ligen und erreicht bei klick auf eine Liga die View League Details View. In dieser View kann man alle Details die Liga anschauen, sowie alle Spieler, welche in dieser Liga spielen. Durch klick auf den Spieler kann in die New Match View gewechselt werden, um einen Spieler herauszufordern. Von der Detail View kann man zusätzlich die Liga löschen, sofern man die Liga erstellt hat oder ein Admin ist.

\subsection{Match Section}
Die Match Section beinhaltet alle Interaktionen im Match. Drei Views sind direkt aus dem Menu erreichbar. Auf der New Match View kann man ein neues Spiel erstellen. Man kann Court, Spieler in einem Formular auswählen. Über den Menupunkt New Broadcast Match View, wählt man ein Court sowie eine Zeit und alle Spieler, welche in diesem Court spielen werden angefragt für eine spontanes Spiel. In der List Match View werden alle Spiele aufgelistet. Von da kommt man in die View Match Details View, welche den Matchworkflow abdeckt.

